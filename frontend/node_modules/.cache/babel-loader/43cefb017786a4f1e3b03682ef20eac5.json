{"remainingRequest":"/home/andrey/Документы/Andrgit/Study/Golang/Operations-Manager/frontend/node_modules/thread-loader/dist/cjs.js!/home/andrey/Документы/Andrgit/Study/Golang/Operations-Manager/frontend/node_modules/babel-loader/lib/index.js!/home/andrey/Документы/Andrgit/Study/Golang/Operations-Manager/frontend/src/plugins/panel/panelCloning.js","dependencies":[{"path":"/home/andrey/Документы/Andrgit/Study/Golang/Operations-Manager/frontend/src/plugins/panel/panelCloning.js","mtime":1569500720485},{"path":"/home/andrey/Документы/Andrgit/Study/Golang/Operations-Manager/frontend/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/andrey/Документы/Andrgit/Study/Golang/Operations-Manager/frontend/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/andrey/Документы/Andrgit/Study/Golang/Operations-Manager/frontend/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/web.dom.iterable\";\n\n// #region clone functional\n\n/**\n * Will return the cloned Array\n * @param { Array } array \n */\nconst cloneArray = function cloneArray(array) {\n  let cloneElement = [];\n  array.forEach(iter => {\n    cloneElement.push(getClone(iter));\n  });\n  return cloneElement;\n};\n/**\n * Will return the cloned Object\n * @param { Object } obj \n */\n\n\nconst cloneObject = function cloneObject(obj) {\n  let cloneElement = Object.create(Object.getPrototypeOf(obj));\n\n  for (let prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      cloneElement[prop] = getClone(obj[prop]);\n    }\n  }\n\n  return cloneElement;\n};\n/**\n * Will return the cloned Function\n * @param { Function } f \n */\n\n\nconst cloneFunction = function cloneFunction(f) {\n  // let that = f;\n  // let cloneElement = function() { return that.apply(this, arguments); }; // TODO: Function.prototype.apply need learn more\n  let cloneElement;\n  eval('cloneElement=' + f.toString()); // let cloneElement = new Function('return ' + f.toString())();\n\n  for (let key in f) {\n    if (f.hasOwnProperty(key)) {\n      cloneElement[key] = f[key];\n    }\n  }\n\n  return cloneElement;\n};\n/**\n * Will return the cloned Date\n * @param { Date } d \n */\n\n\nconst cloneDate = function cloneDate(d) {\n  let cloneElement = new Date(d);\n  return cloneElement;\n}; // #region const variables types\n\n\nconst addedTypes = {};\n/**\n * primitive types for equal value only\n */\n\nconst primitiveTypes = ['[object Undefined]', '[object Null]', '[object Boolean]', '[object Symbol]', '[object String]', '[object Number]', '[object BigInt]'];\n/**\n * complex types to get the value using a function of a specific type\n */\n\nconst complexTypes = {\n  '[object Array]': cloneArray,\n  '[object Object]': cloneObject,\n  '[object Function]': cloneFunction,\n  '[object Date]': cloneDate\n};\nconst complexTypes_ = Object.keys(complexTypes); // #endregion\n\n/**\n * Method for cloning certain types\n * @param { any } value object for cloning\n */\n\nconst getClone = function getClone(value) {\n  const addedTypes_ = Object.keys(addedTypes);\n  const type = Object.prototype.toString.call(value);\n\n  if (primitiveTypes.indexOf(type) !== -1) {\n    // primitiveTypes\n    return value;\n  } else if (complexTypes_.indexOf(type) !== -1) {\n    // complexTypes\n    return complexTypes[type](value);\n  } else if (addedTypes_.indexOf(type) !== -1) {\n    // addedType\n    return addedTypes[type](value);\n  } else {\n    // undefined type\n    throw new Error('Unknown type, please add its implementation to the getClone function using the addNewType method');\n  } // return JSON.parse(JSON.stringify(value));\n\n};\n/**\n * function for adding a type and cloning it into a common getClone method.\n * You can use the getClone method in your implementation to get deep cloning.\n * @param { String } type Use Object.prototype.toString.call(type) \n * @param { Function } f Type cloning function\n * @param { Boolean } reWrite Default value false. Option to override method for addedType\n * @returns { void }\n */\n\n\nconst addNewType = function addNewType(type, f) {\n  let reWrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (Object.prototype.toString.call(f) === '[object Function]' && Object.prototype.toString.call(type) === '[object String]') {\n    if (!addedTypes.hasOwnProperty(type) || addedTypes.hasOwnProperty(type) && reWrite) {\n      addedTypes[type] = f;\n      console.log(`[panelCloning.js]: addNewType: Success add new type \"${type}\"`);\n    } else {\n      console.warn(\"This type has already been added to the cloning method. If you want to overwrite, you must specify the reWrite as true\");\n    }\n  } else {\n    console.error(\"Type error, check input\");\n  }\n}; // #endregion \n\n\nexport { getClone, addNewType };\nexport default {\n  getClone,\n  addNewType\n};",{"version":3,"sources":["/home/andrey/Документы/Andrgit/Study/Golang/Operations-Manager/frontend/src/plugins/panel/panelCloning.js"],"names":["cloneArray","array","cloneElement","forEach","iter","push","getClone","cloneObject","obj","Object","create","getPrototypeOf","prop","hasOwnProperty","cloneFunction","f","eval","toString","key","cloneDate","d","Date","addedTypes","primitiveTypes","complexTypes","complexTypes_","keys","value","addedTypes_","type","prototype","call","indexOf","Error","addNewType","reWrite","console","log","warn","error"],"mappings":"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","sourcesContent":["// #region clone functional\n\n/**\n * Will return the cloned Array\n * @param { Array } array \n */\nconst cloneArray = function(array) {\n    let cloneElement = [];\n    array.forEach(iter => {\n        cloneElement.push(getClone(iter));\n    });\n    return cloneElement;\n};\n\n/**\n * Will return the cloned Object\n * @param { Object } obj \n */\nconst cloneObject = function(obj) {\n    let cloneElement = Object.create(Object.getPrototypeOf(obj));\n    for (let prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n            cloneElement[prop] = getClone(obj[prop]);\n        }\n    }\n    return cloneElement;\n};\n\n/**\n * Will return the cloned Function\n * @param { Function } f \n */\nconst cloneFunction = function(f) {\n    // let that = f;\n    // let cloneElement = function() { return that.apply(this, arguments); }; // TODO: Function.prototype.apply need learn more\n    \n    let cloneElement;\n    eval('cloneElement=' + f.toString());\n    \n    // let cloneElement = new Function('return ' + f.toString())();\n    for (let key in f) {\n        if (f.hasOwnProperty(key)) {\n            cloneElement[key] = f[key];\n        }\n    }\n    return cloneElement;\n};\n\n/**\n * Will return the cloned Date\n * @param { Date } d \n */\nconst cloneDate = function(d) {\n    let cloneElement = new Date(d);\n    return cloneElement;\n};\n\n// #region const variables types\nconst addedTypes = {};\n\n/**\n * primitive types for equal value only\n */\nconst primitiveTypes = [\n    '[object Undefined]',\n    '[object Null]',\n    '[object Boolean]',\n    '[object Symbol]',\n    '[object String]',\n    '[object Number]',\n    '[object BigInt]'\n];\n\n/**\n * complex types to get the value using a function of a specific type\n */\nconst complexTypes = {\n    '[object Array]': cloneArray,\n    '[object Object]': cloneObject,\n    '[object Function]': cloneFunction,\n    '[object Date]': cloneDate\n};\nconst complexTypes_ = Object.keys(complexTypes);\n// #endregion\n\n\n/**\n * Method for cloning certain types\n * @param { any } value object for cloning\n */\nconst getClone = function(value) {\n    const addedTypes_ = Object.keys(addedTypes);\n    const type = Object.prototype.toString.call(value);\n\n    if (primitiveTypes.indexOf(type) !== -1) {              // primitiveTypes\n        return value;\n    } else if (complexTypes_.indexOf(type) !== -1) {         // complexTypes\n        return complexTypes[type](value);\n    } else if (addedTypes_.indexOf(type) !== -1) {          // addedType\n        return addedTypes[type](value);\n    } else {                                                // undefined type\n        throw new Error('Unknown type, please add its implementation to the getClone function using the addNewType method')\n    }\n    // return JSON.parse(JSON.stringify(value));\n};\n\n/**\n * function for adding a type and cloning it into a common getClone method.\n * You can use the getClone method in your implementation to get deep cloning.\n * @param { String } type Use Object.prototype.toString.call(type) \n * @param { Function } f Type cloning function\n * @param { Boolean } reWrite Default value false. Option to override method for addedType\n * @returns { void }\n */\nconst addNewType = function(type, f, reWrite = false) {\n    if (Object.prototype.toString.call(f) === '[object Function]' && \n        Object.prototype.toString.call(type) === '[object String]') {\n        if (!addedTypes.hasOwnProperty(type) || (addedTypes.hasOwnProperty(type) && reWrite)) {\n            addedTypes[type] = f;\n            console.log(`[panelCloning.js]: addNewType: Success add new type \"${ type }\"`);\n        } else {\n            console.warn(\"This type has already been added to the cloning method. If you want to overwrite, you must specify the reWrite as true\")\n        }\n    } else {    \n        console.error(\"Type error, check input\")\n    }\n}\n// #endregion \n\nexport {\n    getClone,\n    addNewType\n}\n\nexport default {\n    getClone,\n    addNewType\n}"]}]}