{"remainingRequest":"/home/andrey/Документы/Andrgit/Study/Golang/Operations-Manager/frontend/node_modules/babel-loader/lib/index.js!/home/andrey/Документы/Andrgit/Study/Golang/Operations-Manager/frontend/src/plugins/panel/panelEquals.js","dependencies":[{"path":"/home/andrey/Документы/Andrgit/Study/Golang/Operations-Manager/frontend/src/plugins/panel/panelEquals.js","mtime":1568967510060},{"path":"/home/andrey/Документы/Andrgit/Study/Golang/Operations-Manager/frontend/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/andrey/Документы/Andrgit/Study/Golang/Operations-Manager/frontend/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.object.keys\";\n\n// #region equal functional\n\n/**\n * Will return Array comparison\n * @param { Array } array1\n * @param { Array } array2 \n * @returns { Boolean }\n */\nvar equalArray = function equalArray(array1, array2) {\n  var length = array1.length,\n      length2 = array2.length;\n  if (length !== length2) return false;\n\n  for (var i = 0; i < length; i++) {\n    if (!isEqual(array1[i], array2[i])) return false;\n  }\n\n  return true;\n};\n/**\n * Will return Object comparison\n * @param { Object } obj1\n * @param { Object } obj2 \n */\n\n\nvar equalObject = function equalObject(obj1, obj2) {\n  var length = Object.keys(obj1).length,\n      length2 = Object.keys(obj2).length;\n  if (length !== length2) return false;\n\n  for (var key in obj1) {\n    if (obj2.hasOwnProperty(key)) {\n      if (!isEqual(obj1[key], obj2[key])) return false;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Will return Function comparison\n * @param { Function } f1\n * @param { Function } f2\n */\n\n\nvar equalFunction = function equalFunction(f1, f2) {\n  console.log(f1.toString(), f2.toString());\n  return f1.toString() === f2.toString();\n};\n/**\n * Will return Date comparison\n * @param { Date } d1\n * @param { Date } d2 \n */\n\n\nvar equalDate = function equalDate(d1, d2) {\n  return d1.getTime() === d2.getTime();\n}; // #region const variables types\n\n\nvar addedTypes = {};\n/**\n * primitive types for equal value only\n */\n\nvar primitiveTypes = ['[object Undefined]', '[object Null]', '[object Boolean]', '[object Symbol]', '[object String]', '[object Number]', '[object BigInt]'];\n/**\n * complex types to get the value using a function of a specific type\n */\n\nvar complexTypes = {\n  '[object Array]': equalArray,\n  '[object Object]': equalObject,\n  '[object Function]': equalFunction,\n  '[object Date]': equalDate\n};\nvar complexTypes_ = Object.keys(complexTypes); // #endregion\n\n/**\n * Method for equal values from value2\n * @param { any } value1 any Type\n * @param { any } value2 if value type \"Array\", get once equals of array else return value1 === value2\n */\n\nvar isEqualOf = function isEqualOf(value1, value2) {\n  var type = Object.prototype.toString.call(value2);\n\n  if (type === '[object Array]') {\n    // isEqualOnce from array\n    var length = value2.length;\n\n    if (length > 0) {\n      for (var i = 0; i < value1; i++) {\n        if (isEqual(value1, valu2[i])) return true;\n      }\n    }\n\n    return false;\n  }\n\n  return isEqual(value1, value2);\n};\n/**\n * Method for equal values\n * @param { any } value1 element for equal with value2\n * @param { any } value2 element for equal with value1\n */\n\n\nvar isEqual = function isEqual(value1, value2) {\n  // Get the values type\n  var type = Object.prototype.toString.call(value1),\n      type2 = Object.prototype.toString.call(value2); // If the two values are not the same type, return false\n\n  if (type !== type2) return false;\n  var addedTypes_ = Object.keys(addedTypes); // array with addedTypes\n\n  if (primitiveTypes.indexOf(type) !== -1) {\n    // primitiveTypes\n    return value1 === value2;\n  } else if (complexTypes_.indexOf(type) !== -1) {\n    // complexTypes\n    return complexTypes[type](value1, value2);\n  } else if (addedTypes_.indexOf(type) !== -1) {\n    // addedType\n    return addedTypes[type](value1, value2);\n  } else {\n    // undefined type\n    throw new Error('Unknown type, please add its implementation to the isEqual function using the addNewEqualType method');\n  }\n};\n/**\n * function for adding a type and cloning it into a common getClone method.\n * You can use the getClone method in your implementation to get deep cloning.\n * @param { String } type Use Object.prototype.toString.call(type) \n * @param { Function } f Type cloning function\n * @param { Boolean } reWrite Default value false. Option to override method for addedType\n * @returns { void }\n */\n\n\nvar addNewEqualType = function addNewEqualType(type, f) {\n  var reWrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (Object.prototype.toString.call(f) === '[object Function]' && Object.prototype.toString.call(type) === '[object String]') {\n    if (!addedTypes.hasOwnProperty(type) || addedTypes.hasOwnProperty(type) && reWrite) {\n      addedTypes[type] = f;\n      console.log(\"[panelEquals.js]: addNewEqualType: Success add new type \\\"\".concat(type, \"\\\"\"));\n    } else {\n      console.warn(\"This type has already been added to the cloning method. If you want to overwrite, you must specify the reWrite as true\");\n    }\n  } else {\n    console.error(\"Type error, check input\");\n  }\n}; // #endregion \n\n\nexport { isEqual, isEqualOf, addNewEqualType };\nexport default {\n  isEqual: isEqual,\n  isEqualOf: isEqualOf,\n  addNewEqualType: addNewEqualType\n}; // /**\n//  * Function is equals object from types (Array, Object, Function, Number, String, Boolean), any object types equals as value1 === value2;\n//  * @param {*} value1 First object for equal\n//  * @param {*} value2 Second object for equal\n//  */\n// const isEqual = function(value1, value2) {\n//     // Get the value type\n//     let type = Object.prototype.toString.call(value1);\n//     let type_2 = Object.prototype.toString.call(value2);\n//     // If the two values are not the same type, return false\n//     if (type !== type_2) return false;\n//     let objectTypes = [ \n//         '[object Array]',\n//         '[object Object]'\n//     ];\n//     // let primitiveTypes = [\n//     //     '[object Boolean]',\n//     //     '[object Number]',\n//     //     '[object String]'\n//     // ];\n//     // // If items are not an object or array return false;\n//     // if (objectTypes.indexOf(type) < 0 && primitiveTypes.indexOf(type) < 0) return false;\n//     // // If items are primitive types return === value;\n//     // if (primitiveTypes.indexOf(type) !== -1) return value1 === value_;\n//     // If items is functions\n//     if (type === '[object Function]') return value1.toString() === value2.toString();\n//     // If items are not an object or array return === equals;\n//     if (objectTypes.indexOf(type) < 0) return value1 === value2;\n//     // Compare the length of the length of the two items\n//     let value1Len = type === '[object Array]' ? value1.length : Object.keys(value1).length;\n//     let value2Len = type === '[object Array]' ? value2.length : Object.keys(value2).length;\n//     if (value1Len !== value2Len) return false;\n//     // Compare properties\n//     if (type === '[object Array]') {\n//         for (let i = 0; i < value1Len; i++) {\n//             if (!isEqual(value1[i], value2[i])) return false;\n//         } \n//     } else {\n//         for (let key in value1) {\n//             if (value2.hasOwnProperty(key)) {\n//                 if (!isEqual(value1[key], value2[key])) return false;\n//             } else {\n//                 return false;\n//             }\n//         }\n//     }\n//     // if nothing failed, return true\n//     return true;\n// };\n// export default isEqual;",{"version":3,"sources":["/home/andrey/Документы/Andrgit/Study/Golang/Operations-Manager/frontend/src/plugins/panel/panelEquals.js"],"names":["equalArray","array1","array2","length","length2","i","isEqual","equalObject","obj1","obj2","Object","keys","key","hasOwnProperty","equalFunction","f1","f2","console","log","toString","equalDate","d1","d2","getTime","addedTypes","primitiveTypes","complexTypes","complexTypes_","isEqualOf","value1","value2","type","prototype","call","valu2","type2","addedTypes_","indexOf","Error","addNewEqualType","f","reWrite","warn","error"],"mappings":"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","sourcesContent":["// #region equal functional\n\n/**\n * Will return Array comparison\n * @param { Array } array1\n * @param { Array } array2 \n * @returns { Boolean }\n */\nconst equalArray = function(array1, array2) {\n    let length = array1.length,\n        length2 = array2.length;\n    \n    if (length !== length2) return false;\n    for (let i = 0; i < length; i++) {\n        if (!isEqual(array1[i], array2[i])) return false;\n    }\n\n    return true;\n};\n\n/**\n * Will return Object comparison\n * @param { Object } obj1\n * @param { Object } obj2 \n */\nconst equalObject = function(obj1, obj2) {\n    let length = Object.keys(obj1).length,\n        length2 = Object.keys(obj2).length;\n    \n    if (length !== length2) return false;\n    for (let key in obj1) {\n        if (obj2.hasOwnProperty(key)) {\n            if (!isEqual(obj1[key], obj2[key])) return false;\n        } else {\n            return false;\n        }\n    }\n\n    return true;\n};\n\n/**\n * Will return Function comparison\n * @param { Function } f1\n * @param { Function } f2\n */\nconst equalFunction = function(f1, f2) {\n    console.log(f1.toString(), f2.toString());\n    return f1.toString() === f2.toString();\n};\n\n/**\n * Will return Date comparison\n * @param { Date } d1\n * @param { Date } d2 \n */\nconst equalDate = function(d1, d2) {\n    return d1.getTime() === d2.getTime();\n};\n// #region const variables types\nconst addedTypes = {};\n\n/**\n * primitive types for equal value only\n */\nconst primitiveTypes = [\n    '[object Undefined]',\n    '[object Null]',\n    '[object Boolean]',\n    '[object Symbol]',\n    '[object String]',\n    '[object Number]',\n    '[object BigInt]'\n];\n\n/**\n * complex types to get the value using a function of a specific type\n */\nconst complexTypes = {\n    '[object Array]': equalArray,\n    '[object Object]': equalObject,\n    '[object Function]': equalFunction,\n    '[object Date]': equalDate\n};\nconst complexTypes_ = Object.keys(complexTypes);\n// #endregion\n\n/**\n * Method for equal values from value2\n * @param { any } value1 any Type\n * @param { any } value2 if value type \"Array\", get once equals of array else return value1 === value2\n */\nconst isEqualOf = function(value1, value2) {\n    let type = Object.prototype.toString.call(value2);\n    if (type === '[object Array]') {        // isEqualOnce from array\n        let length = value2.length;\n        if (length > 0) {\n            for (let i = 0; i < value1; i++) {\n                if (isEqual(value1, valu2[i])) return true;\n            }\n        }\n        return false;\n    } \n    return isEqual(value1, value2);\n    \n}\n\n/**\n * Method for equal values\n * @param { any } value1 element for equal with value2\n * @param { any } value2 element for equal with value1\n */\nconst isEqual = function(value1, value2) {\n    // Get the values type\n    const type = Object.prototype.toString.call(value1),\n          type2 = Object.prototype.toString.call(value2);\n    \n    // If the two values are not the same type, return false\n    if (type !== type2) return false;\n\n    const addedTypes_ = Object.keys(addedTypes);            // array with addedTypes\n\n    if (primitiveTypes.indexOf(type) !== -1) {              // primitiveTypes\n        return value1 === value2;\n    } else if (complexTypes_.indexOf(type) !== -1) {         // complexTypes\n        return complexTypes[type](value1, value2);\n    } else if (addedTypes_.indexOf(type) !== -1) {          // addedType\n        return addedTypes[type](value1, value2);\n    } else {                                                // undefined type\n        throw new Error('Unknown type, please add its implementation to the isEqual function using the addNewEqualType method')\n    }\n};\n\n/**\n * function for adding a type and cloning it into a common getClone method.\n * You can use the getClone method in your implementation to get deep cloning.\n * @param { String } type Use Object.prototype.toString.call(type) \n * @param { Function } f Type cloning function\n * @param { Boolean } reWrite Default value false. Option to override method for addedType\n * @returns { void }\n */\nconst addNewEqualType = function(type, f, reWrite = false) {\n    if (Object.prototype.toString.call(f) === '[object Function]' && \n        Object.prototype.toString.call(type) === '[object String]') {\n        if (!addedTypes.hasOwnProperty(type) || (addedTypes.hasOwnProperty(type) && reWrite)) {\n            addedTypes[type] = f;\n            console.log(`[panelEquals.js]: addNewEqualType: Success add new type \"${ type }\"`);\n        } else {\n            console.warn(\"This type has already been added to the cloning method. If you want to overwrite, you must specify the reWrite as true\")\n        }\n    } else {    \n        console.error(\"Type error, check input\")\n    }\n}\n// #endregion \n\nexport {\n    isEqual,\n    isEqualOf,\n    addNewEqualType\n}\n\nexport default {\n    isEqual,\n    isEqualOf,\n    addNewEqualType\n}\n\n\n\n\n// /**\n//  * Function is equals object from types (Array, Object, Function, Number, String, Boolean), any object types equals as value1 === value2;\n//  * @param {*} value1 First object for equal\n//  * @param {*} value2 Second object for equal\n//  */\n// const isEqual = function(value1, value2) {\n    \n//     // Get the value type\n//     let type = Object.prototype.toString.call(value1);\n//     let type_2 = Object.prototype.toString.call(value2);\n\n//     // If the two values are not the same type, return false\n//     if (type !== type_2) return false;\n\n//     let objectTypes = [ \n//         '[object Array]',\n//         '[object Object]'\n//     ];\n\n//     // let primitiveTypes = [\n//     //     '[object Boolean]',\n//     //     '[object Number]',\n//     //     '[object String]'\n//     // ];\n//     // // If items are not an object or array return false;\n//     // if (objectTypes.indexOf(type) < 0 && primitiveTypes.indexOf(type) < 0) return false;\n\n//     // // If items are primitive types return === value;\n//     // if (primitiveTypes.indexOf(type) !== -1) return value1 === value_;\n    \n//     // If items is functions\n//     if (type === '[object Function]') return value1.toString() === value2.toString();\n    \n//     // If items are not an object or array return === equals;\n//     if (objectTypes.indexOf(type) < 0) return value1 === value2;\n\n//     // Compare the length of the length of the two items\n//     let value1Len = type === '[object Array]' ? value1.length : Object.keys(value1).length;\n//     let value2Len = type === '[object Array]' ? value2.length : Object.keys(value2).length;\n    \n//     if (value1Len !== value2Len) return false;\n\n//     // Compare properties\n//     if (type === '[object Array]') {\n//         for (let i = 0; i < value1Len; i++) {\n//             if (!isEqual(value1[i], value2[i])) return false;\n//         } \n//     } else {\n//         for (let key in value1) {\n//             if (value2.hasOwnProperty(key)) {\n//                 if (!isEqual(value1[key], value2[key])) return false;\n//             } else {\n//                 return false;\n//             }\n//         }\n//     }\n\n//     // if nothing failed, return true\n//     return true;\n// };\n\n// export default isEqual;"]}]}